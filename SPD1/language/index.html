<section class="container">
  <div class="static_tab_wrapper">
    <div class="xblock xblock-student_view xblock-student_view-static_tab xmodule_display xmodule_StaticTabModule" data-runtime-class="LmsRuntime" data-init="XBlockToXModuleShim" data-block-type="static_tab" data-request-token="007de66a0b8511e5b33d12f30ef166f7" data-runtime-version="1" data-usage-id="block-v1:UBCx+SPD1x+2T2015+type@static_tab+block@a24b7341216346f2a5c99c6391f64229" data-type="HTMLModule" data-course-id="course-v1:UBCx+SPD1x+2T2015">
  <script type="json/xblock-args" class="xblock-json-init-args">
    {"xmodule-type": "HTMLModule"}
  </script>
  <h2>Language</h2>
<p>This page provides a summary of the programming language used in this course: Beginning Student Language in part 1, then progressing to Intermediate and Advanced) later in the course.</p>
<p></p>
<h4>Values&nbsp;</h4>
<table style="padding: 5px; text-align: left; horizontal-align: left; vertical-align: top;" cellpadding="5">
<tbody>
<tr>
<td>Numbers:</td>
<td><tt>1, 3.5, 1/2, #i1.4142135623730951, ...</tt></td>
</tr>
<tr>
<td>Strings:</td>
<td><tt>"Marvolo", "Black", "carrot", ...</tt></td>
</tr>
<tr>
<td>Images:</td>
<td><img src="https://spark-public.s3.amazonaws.com/programdesign/image_files/green-triangle.png">, <img src="https://spark-public.s3.amazonaws.com/programdesign/image_files/red-square.png">,...</td>
</tr>
<tr>
<td>Booleans:</td>
<td><tt>true, false</tt></td>
</tr>
<tr>
<td>Compound data:</td>
<td><tt>(make-person "Claude" "Monet"), ...</tt></td>
</tr>
<tr>
<td>Lists:</td>
<td><tt>empty, (cons 2 (cons 1 empty)), (cons "x" (cons "y" (cons "z" empty))), ...</tt></td>
</tr>
</tbody>
</table>
<p></p>
<p>NOTE: The primitive types are: <tt> Number, Integer, Natural </tt>(Integers greater than or equal to 0)<tt>, String, Image and Boolean<br><span face="Helvetica Neue, Helvetica, Arial, sans-serif" style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2htdp/image also provides a primitive Color type</span></tt></p>
<h4>Primitive Operations</h4>
<p><tt>+, -, *, / ...<br> string-append, string-length, substring ...<br> circle, square, overlay, above, beside...<br>not, =, &lt;, &gt;, string=?, string&lt;?, cons, first, rest, empty?, cons?</tt></p>
<h4>Forming Expressions</h4>
<p></p>
<table style="border: .5px solid #000000; padding: 5px; text-align: left; horizontal-align: left; vertical-align: top;" border="1" cellpadding="5">
<thead>
<tr><th scope="col" width="60%">Form</th><th scope="col">Example</th></tr>
</thead>
<tbody>
<tr>
<td><tt>&lt;value&gt;</tt></td>
<td><tt>3</tt></td>
</tr>
<tr>
<td><tt>&lt;name-of-defined-constant&gt;</tt></td>
<td><tt>WIDTH</tt></td>
</tr>
<tr>
<td><tt>(&lt;name-of-primitive-operation&gt; &lt;expression&gt; ...)</tt></td>
<td><tt>(+ 2 (* 3 6))</tt></td>
</tr>
<tr>
<td><tt>(&lt;name-of-defined-function&gt; &lt;expression&gt; ...)</tt> <br> <br>A function call should have the same number of operands as parameters.</td>
<td><tt>(yell "hello")</tt></td>
</tr>
<tr>
<td><tt>(if&nbsp;&lt;question&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&lt;true-answer&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&lt;false-answer&gt;)</tt> <br> <br><tt>&lt;question&gt;</tt> must be an expression that evaluates to a boolean. <br><tt>&lt;true-answer&gt;</tt> and <tt>&lt;false-answer&gt;</tt> must be expressions.</td>
<td><tt>(if (&gt; (string-length x) 3)<br> &nbsp;&nbsp;&nbsp;&nbsp;"long"<br> &nbsp;&nbsp;&nbsp;&nbsp;"short")</tt></td>
</tr>
<tr>
<td><tt>(cond [&lt;question&gt; &lt;answer&gt;]<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)</tt> <br> <br>Each <tt>&lt;question&gt;</tt> must be either <tt>else</tt> or an expression that evaluates to a boolean. <br>Each <tt>&lt;answer&gt;</tt> must be an expression.</td>
<td><tt>(cond [(&gt; x y) "more"]<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(&lt; x y) "less"]<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else "same"])<tt> </tt></tt></td>
</tr>
<tr>
<td><tt>(and &lt;question&gt;&nbsp;...)</tt> <br> <br>Each <tt>&lt;question&gt;</tt> must be an expression that evaluates to a boolean.</td>
<td><tt>(and (&lt; 0 x) (&gt;= x 10))</tt></td>
</tr>
<tr>
<td><tt>(or &lt;question&gt;&nbsp;...)</tt> <br> <br>Each <tt>&lt;question&gt;</tt> must be an expression that evaluates to a boolean.</td>
<td><tt>(or (&lt; x 0) (&gt; x 10))</tt></td>
</tr>
<tr>
<td><tt><i>Intermediate Student Language</i><br><br>(local [&lt;definition&gt;...] <br>&nbsp; &nbsp;&lt;expression&gt;)</tt> <br> <br>Any function or constant defined within the <tt>local</tt> is valid within the entire body of <br>the local expression, but not outside of the local expression.&nbsp;</td>
<td><tt><br>(local [(define DOT&nbsp;(circle 5 "solid" "red"))<br>&nbsp; &nbsp; &nbsp; &nbsp; (define (add-dot img)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (beside img DOT))]&nbsp;<br>&nbsp; &nbsp;(add-dot (square 20 "solid" "blue")))<br><br></tt></td>
</tr>
</tbody>
</table>
<p></p>
<h4>Forming Definitions</h4>
<pre>(define SIZE (* 3 6))         ;a constant definition, the value of SIZE is 18
</pre>
<pre>(define (bulb c)              ;defines a function named bulb, with parameter c
  (circle 30 "solid" c))      ;this is the body of the function
</pre>
<pre>(define-struct wand (wood core length))  ;defines the functions below:

; constructor: make-wand
; selectors:   wand-wood, wand-core, wand-length
; predicate:   wand?
</pre>
<p></p>
<h4>Evaluation Rules</h4>
<p>For a <strong>constant reference</strong>, such as <tt>SIZE</tt>:</p>
<ul>
<li>The constant reference evaluates to the defined value of the constant.</li>
</ul>
<p>For a <strong>call to a primitive</strong> such as <tt>(+ 2 (* 3 6))</tt>:</p>
<ul>
<li>First reduce the operands to values: proceed left to right making sure all the operands are values, for any that are not, evaluate them. <br>These values are called the arguments to the primitive.</li>
<li>Apply the primitive to those arguments.</li>
</ul>
<p>For a <strong>call to a defined function</strong> such as <tt>(bulb (string-append "r" "ed"))</tt>:</p>
<ul>
<li>First reduce the operands to values (as for a call to a primitive). These values are called the arguments to the function.</li>
<li>Replace the function call expression with the body of the function in which every occurrence of the parameter(s) has been replaced by the corresponding argument(s).</li>
</ul>
<p>For example:</p>
<pre>(bulb (string-append "r" "ed"))
(bulb "red")
(circle 30 "solid" "red")
</pre>
<p>For an <strong>if expression</strong>:</p>
<ul>
<li>If the question is not a value, evaluate it and replace it with its value.</li>
<li>If the question is <tt>true</tt>, replace the entire if expression with the true answer expression.</li>
<li>If the question is <tt>false</tt>, replace the entire if expression with the false answer expression</li>
<li>If the question is a value other than <tt>true</tt> or <tt>false</tt>, signal an error</li>
</ul>
<p>For example:</p>
<pre>(if (&gt; (+ 1 2) 3)     
    (* 2 3)          
    (* 3 4))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;since (&gt; (+ 1 2) 3) is an expression, not a value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;evaluate it left to right
(if (&gt; 3 3)
    (* 2 3)
    (* 3 4))       

(if false     
    (* 2 3) 
    (* 3 4))           
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;replace entire if expression with the false answer expression
(* 3 4)    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;evaluate false answer expression 
12
</pre>
<p></p>
<p>For a <strong>cond expression</strong>:</p>
<ul>
<li>If there are no question/answer pairs, signal an error.</li>
<li>If the first question is not a value, evaluate it and replace it with its value. That is, replace the entire <tt>cond</tt> with a new <tt>cond</tt> in which the first question has been replaced by its value.</li>
<li>If the first question is <tt>true</tt> or <tt>else</tt>, replace the entire <tt>cond</tt> expression with the first answer.</li>
<li>If the first question is <tt>false</tt> drop the first question/answer pair; that is, replace the <tt>cond</tt> with a new <tt>cond</tt> that does not have the first question/answer pair</li>
  <li>Since the first question is a value other than <tt>else</tt>,&nbsp;<tt>true</tt> or <tt>false</tt>, signal an error. </li>
</ul>
<p>For example:</p>
<pre>(cond [(&gt; 3 3) "more"]     
      [(&lt; 3 3) "less"]     
      [else "same"]) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;the first question is not a value, the expression
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;(&gt; 3 3) is evaluated and replaced with a value
(cond [false "more"]        
      [(&lt; 3 3) "less"]                            
      [else "same"])     
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;the first question is false, so the first
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;question/answer pair is dropped &nbsp;
(cond [(&lt; 3 3) "less"]     
      [else "same"])       
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;the first question is not a value, so (&lt; 3 3) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;is evaluated and replaced with its value
(cond [false "less"]       
      [else "same"])       
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;the first question is false, so the first
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;question/answer pair is dropped 
(cond [else "same"])       
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;since the question is else, the entire cond expression            
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;is replaced by the answer               
"same"</pre>
<p>For an <strong>and expression</strong>:</p>
<ul>
<li>If there are no expressions produce <tt>true</tt>.</li>
<li>If the first expression is not a value, evaluate it and replace it with its value.</li>
<li>If the first expression is <tt>false</tt> produce <tt>false</tt></li>
<li>If the first expression is <tt>true</tt> replace the entire <tt>and</tt> expression with an <tt>and</tt> expression without the first expression.</li>
<li>If the first expression is a value other than <tt>true</tt> or <tt>false</tt>, signal an error.</li>
</ul>
<p>For example:</p>
<pre>(and (&lt; 0 3) 
     (&lt; 3 10))  &nbsp;&nbsp;;since (&lt; 0 3) is an expression, not a value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;evaluate it
(and true        
     (&lt; 3 10))    ;first expression is true, drop it from the and    

(and (&lt; 3 10))    ;now evaluate (&lt; 3 10)       
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(and true)        ;now drop true

(and)             ;an empty and produces true
</pre>
<p>For an&nbsp;<strong>or expression</strong>:</p>
<ul>
<li>If there are no expressions produce&nbsp;<tt>false</tt>.</li>
<li>If the first expression is not a value, evaluate it and replace it with its value.</li>
<li>If the first expression is&nbsp;<tt>true</tt>&nbsp;produce&nbsp;<tt>true</tt></li>
<li>If the first expression is&nbsp;<tt>false</tt>&nbsp;replace the entire&nbsp;<tt>or</tt>&nbsp;expression with an&nbsp;<tt>or</tt>&nbsp;expression without the first expression.</li>
<li>If the first expression is a value other than&nbsp;<tt>true</tt>&nbsp;or&nbsp;<tt>false</tt>, signal an error.</li>
</ul>
<p>For example:</p>
<pre>(or (&lt; 14 0)
    (&gt; 14 10))  &nbsp;&nbsp;;since (&lt; 14 0) is an expression, not a value,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;evaluate it
(or false        
    (&gt; 14 10))    ;first expression is false, drop it from the and    

(or (&gt; 14 10))    ;now evaluate (&gt; 14 10)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(or true)         ;first expression is true so produce true

true</pre>
<p><br> <br><i>Intermediate Student Language</i></p>
<p>For a <strong>local expression</strong>:</p>
<ul>
<li>For each locally defined function or constant, rename it and all references to it to a globally unique name, and</li>
<li><strong>in the same step</strong> lift the local definition(s) to the top level with any existing global definitions, and</li>
<li><strong>in the same step</strong> replace the local expression with the body of the local in which all references to the defined functions and constants have been renamed.</li>
</ul>
<p>For example:</p>
<pre>(define b 1)
(+ b
   (local [(define b 2)]
     (* b b))
   b)
                        ;b evaluates to its defined value, 1


(define b 1)
(+ 1
   (local [(define b 2)]
     (* b b))
   b)
                        ; since b is a locally-defined constant,
                        ;it is renamed to a globally unique name b_0
                        ;the local definition of b_0 is lifted to
                        ;the top level and the entire local expression
                        ;is replaced by its body

(define b 1)
(define b_0 2)          ;---this renamed define was lifted

(+ 1
  (* b_0 b_0)           ;---entire local replaced by renamed body
  b)

                        ;evaluation continues normally from this point
</pre>
<!-- <p>For <strong>lambda</strong> expressions:</p> -->
<p></p>
<h4>Built-In Abstract Functions</h4>
<p>ISL and ASL have the following built-in abstract functions.</p>
<pre>;; Natural (Natural -&gt; X) -&gt; (listof X)
;; produces (list (f 0) ... (f (- n 1)))
(define (build-list n f) ...)

;; (X -&gt; boolean) (listof X) -&gt; (listof X)
;; produce a list from all those items on lox for which p holds
(define (filter p lox) ...)

;; (X -&gt; Y) (listof X) -&gt; (listof Y)
;; produce a list by applying f to each item on lox
;; that is, (map f (list x-1 ... x-n)) = (list (f x-1) ... (f x-n))
(define (map f lox) ...)

;; (X -&gt; boolean) (listof X) -&gt; boolean
;; produce true if p produces true for every element of lox
(define (andmap p lox) ...)

;; (X -&gt; boolean) (listof X) -&gt; boolean
;; produce true if p produces true for some element of lox
(define (ormap p lox) ...)

;; (X Y -&gt; Y) Y (listof X) -&gt; Y
;; (foldr f base (list x-1 ... x-n)) = (f x-1 ... (f x-n base))
(define (foldr f base lox) ...)

;; (X Y -&gt; Y) Y (listof X) -&gt; Y
;; (foldl f base (list x-1 ... x-n)) = (f x-n ... (f x-1 base))
(define (foldl f base lox) ...)
</pre>
<p></p>
</div>

  </div>
</section>